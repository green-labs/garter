// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Id from "@rescript/runtime/lib/es6/Belt_Id.js";
import * as Js_math from "@rescript/runtime/lib/es6/Js_math.js";
import * as Belt_Map from "@rescript/runtime/lib/es6/Belt_Map.js";
import * as Belt_Set from "@rescript/runtime/lib/es6/Belt_Set.js";
import * as Belt_List from "@rescript/runtime/lib/es6/Belt_List.js";
import * as Garter_Fn from "./Garter_Fn.mjs";
import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Belt_MapInt from "@rescript/runtime/lib/es6/Belt_MapInt.js";
import * as Belt_MapString from "@rescript/runtime/lib/es6/Belt_MapString.js";
import * as Primitive_object from "@rescript/runtime/lib/es6/Primitive_object.js";

function isEmpty(xs) {
  return xs.length === 0;
}

function firstUnsafe(__x) {
  return __x[0];
}

function firstExn(__x) {
  return Belt_Array.getExn(__x, 0);
}

function first(__x) {
  return Belt_Array.get(__x, 0);
}

function lastUnsafe(ar) {
  return ar[ar.length - 1 | 0];
}

function lastExn(ar) {
  return Belt_Array.getExn(ar, ar.length - 1 | 0);
}

function last(ar) {
  return Belt_Array.get(ar, ar.length - 1 | 0);
}

function take(ar, n) {
  let len = n < 0 ? 0 : (
      n > ar.length ? ar.length : n
    );
  return ar.slice(0, len);
}

function takeWhile(ar, pred) {
  let i = 0;
  while (i < ar.length && pred(ar[i])) {
    i = i + 1 | 0;
  };
  return take(ar, i);
}

function drop(ar, n) {
  let offset = n < 0 ? 0 : (
      n > ar.length ? ar.length : n
    );
  return ar.slice(offset);
}

function dropWhile(ar, pred) {
  let i = 0;
  while (i < ar.length && pred(ar[i])) {
    i = i + 1 | 0;
  };
  return drop(ar, i);
}

function updateUnsafe(ar, i, f) {
  let v = ar[i];
  ar[i] = f(v);
}

function updateExn(ar, i, f) {
  let v = Belt_Array.getExn(ar, i);
  ar[i] = f(v);
}

function keepSome(xs) {
  return Belt_Array.keepMap(xs, x => x);
}

function groupBy(xs, keyFn, id) {
  let empty = Belt_Map.make(id);
  return Belt_Array.reduce(xs, empty, (res, x) => Belt_Map.update(res, keyFn(x), v => {
    if (v !== undefined) {
      return Belt_Array.concat(v, [x]);
    } else {
      return [x];
    }
  }));
}

function indexBy(xs, indexFn, id) {
  let empty = Belt_Map.make(id);
  return Belt_Array.reduce(xs, empty, (res, x) => Belt_Map.set(res, indexFn(x), x));
}

function frequencies(ar, id) {
  return Belt_Map.map(groupBy(ar, Garter_Fn.identity, id), prim => prim.length);
}

function distinctBy(ar, f) {
  let cmp = (a, b) => Primitive_object.compare(f(a), f(b));
  let Comparable = Belt_Id.MakeComparable({
    cmp: cmp
  });
  return Belt_List.toArray(Belt_List.reverse(Belt_Array.reduce(ar, [
      Belt_Set.make(Comparable),
      /* [] */0
    ], (param, v) => {
      let res = param[1];
      let seen = param[0];
      if (Belt_Set.has(seen, v)) {
        return [
          seen,
          res
        ];
      } else {
        return [
          Belt_Set.add(seen, v),
          Belt_List.add(res, v)
        ];
      }
    })[1]));
}

function distinct(ar) {
  return distinctBy(ar, x => x);
}

function scan(xs, init, f) {
  let state = new Array(xs.length);
  let cur = {
    contents: init
  };
  Belt_Array.forEachWithIndex(xs, (idx, x) => {
    cur.contents = f(cur.contents, x);
    state[idx] = cur.contents;
  });
  return state;
}

function chunk(xs, step) {
  return Belt_Array.map(Belt_Array.rangeBy(0, xs.length - 1 | 0, step), offset => xs.slice(offset, offset + step | 0));
}

function randomOne(xs) {
  return Belt_Array.get(xs, Js_math.random_int(0, xs.length));
}

function randomSample(xs, prob) {
  return Belt_Array.keep(xs, param => Math.random() < prob);
}

function intersperse(xs, delim) {
  let xlen = xs.length;
  if (xlen === 0) {
    return [];
  }
  if (xlen === 1) {
    return xs;
  }
  let ys = Belt_Array.make((xlen << 1) - 1 | 0, delim);
  Belt_Array.forEachWithIndex(xs, (i, x) => {
    ys[(i << 1)] = x;
  });
  return ys;
}

function groupBy$1(xs, keyFn) {
  return Belt_Array.reduce(xs, undefined, (res, x) => Belt_MapInt.update(res, keyFn(x), v => {
    if (v !== undefined) {
      return Belt_Array.concat(v, [x]);
    } else {
      return [x];
    }
  }));
}

function indexBy$1(xs, indexFn) {
  return Belt_Array.reduce(xs, undefined, (res, x) => Belt_MapInt.set(res, indexFn(x), x));
}

let Int = {
  groupBy: groupBy$1,
  indexBy: indexBy$1
};

function joinWith(xs, s) {
  return Belt_Array.joinWith(xs, s, x => x);
}

function groupBy$2(xs, keyFn) {
  return Belt_Array.reduce(xs, undefined, (res, x) => Belt_MapString.update(res, keyFn(x), v => {
    if (v !== undefined) {
      return Belt_Array.concat(v, [x]);
    } else {
      return [x];
    }
  }));
}

function indexBy$2(xs, indexFn) {
  return Belt_Array.reduce(xs, undefined, (res, x) => Belt_MapString.set(res, indexFn(x), x));
}

let $$String = {
  joinWith: joinWith,
  groupBy: groupBy$2,
  indexBy: indexBy$2
};

function fromArray(xs) {
  if (xs.length !== 0) {
    return xs;
  }
}

function fromArrayExn(xs) {
  if (xs.length !== 0) {
    return xs;
  }
  throw {
    RE_EXN_ID: "Invalid_argument",
    _1: "array is empty",
    Error: new Error()
  };
}

function toArray(nxs) {
  return nxs;
}

function first$1(nxs) {
  return nxs[0];
}

let last$1 = lastUnsafe;

function reduce1(xs, f) {
  let r = xs[0];
  for (let i = 1, i_finish = xs.length; i < i_finish; ++i) {
    r = f(r, xs[i]);
  }
  return r;
}

function minBy(xs, cmp) {
  return reduce1(xs, (a, b) => {
    if (cmp(a, b) > 0) {
      return b;
    } else {
      return a;
    }
  });
}

function maxBy(xs, cmp) {
  return reduce1(xs, (a, b) => {
    if (cmp(a, b) < 0) {
      return b;
    } else {
      return a;
    }
  });
}

let take$1 = take;

let takeWhile$1 = takeWhile;

let drop$1 = drop;

let dropWhile$1 = dropWhile;

let updateUnsafe$1 = updateUnsafe;

let updateExn$1 = updateExn;

function keepSome$1(nxs) {
  return Belt_Array.keepMap(nxs, x => x);
}

let groupBy$3 = groupBy;

let indexBy$3 = indexBy;

let frequencies$1 = frequencies;

function distinct$1(nxs) {
  return fromArrayExn(distinctBy(nxs, x => x));
}

function distinctBy$1(nxs, f) {
  return fromArrayExn(distinctBy(nxs, f));
}

function scan$1(nxs, init, f) {
  return fromArrayExn(scan(nxs, init, f));
}

function chunk$1(nxs, step) {
  return fromArrayExn(chunk(nxs, step));
}

function randomOne$1(nxs) {
  return nxs[Js_math.random_int(0, nxs.length)];
}

let randomSample$1 = randomSample;

function intersperse$1(nxs, delim) {
  return fromArrayExn(intersperse(nxs, delim));
}

let groupBy$4 = groupBy$1;

let indexBy$4 = indexBy$1;

let Int$1 = {
  groupBy: groupBy$4,
  indexBy: indexBy$4
};

let groupBy$5 = groupBy$2;

let indexBy$5 = indexBy$2;

function length(xs) {
  return xs.length;
}

function size(xs) {
  return xs.length;
}

let get = Belt_Array.get;

let getExn = Belt_Array.getExn;

function getUnsafe(xs, i) {
  return xs[i];
}

function getUndefined(xs, i) {
  return xs[i];
}

let set = Belt_Array.set;

let setExn = Belt_Array.setExn;

function setUnsafe(xs, i, v) {
  xs[i] = v;
}

let shuffleInPlace = Belt_Array.shuffleInPlace;

let shuffle = Belt_Array.shuffle;

let reverseInPlace = Belt_Array.reverseInPlace;

let reverse = Belt_Array.reverse;

let zip = Belt_Array.zip;

let zipBy = Belt_Array.zipBy;

let unzip = Belt_Array.unzip;

let concat = Belt_Array.concat;

let concatMany = Belt_Array.concatMany;

let slice = Belt_Array.slice;

let sliceToEnd = Belt_Array.sliceToEnd;

function copy(xs) {
  return xs.slice(0);
}

let fill = Belt_Array.fill;

let blit = Belt_Array.blit;

let blitUnsafe = Belt_Array.blitUnsafe;

let forEach = Belt_Array.forEach;

let map = Belt_Array.map;

let getBy = Belt_Array.getBy;

let getIndexBy = Belt_Array.getIndexBy;

let keep = Belt_Array.keep;

let keepWithIndex = Belt_Array.keepWithIndex;

let keepMap = Belt_Array.keepMap;

let forEachWithIndex = Belt_Array.forEachWithIndex;

let mapWithIndex = Belt_Array.mapWithIndex;

let partition = Belt_Array.partition;

let reduce = Belt_Array.reduce;

let reduceReverse = Belt_Array.reduceReverse;

let reduceReverse2 = Belt_Array.reduceReverse2;

let reduceWithIndex = Belt_Array.reduceWithIndex;

let joinWith$1 = Belt_Array.joinWith;

let some = Belt_Array.some;

let every = Belt_Array.every;

let some2 = Belt_Array.some2;

let every2 = Belt_Array.every2;

let cmp = Belt_Array.cmp;

let eq = Belt_Array.eq;

function truncateToLengthUnsafe(xs, n) {
  xs.length = n;
}

let get$1 = Belt_Array.get;

let getExn$1 = Belt_Array.getExn;

let getOrThrow = Belt_Array.getOrThrow;

let set$1 = Belt_Array.set;

let setExn$1 = Belt_Array.setExn;

let setOrThrow = Belt_Array.setOrThrow;

let shuffleInPlace$1 = Belt_Array.shuffleInPlace;

let shuffle$1 = Belt_Array.shuffle;

let reverseInPlace$1 = Belt_Array.reverseInPlace;

let reverse$1 = Belt_Array.reverse;

let make = Belt_Array.make;

let range = Belt_Array.range;

let rangeBy = Belt_Array.rangeBy;

let makeByU = Belt_Array.makeByU;

let makeBy = Belt_Array.makeBy;

let makeByAndShuffleU = Belt_Array.makeByAndShuffleU;

let makeByAndShuffle = Belt_Array.makeByAndShuffle;

let zip$1 = Belt_Array.zip;

let zipByU = Belt_Array.zipByU;

let zipBy$1 = Belt_Array.zipBy;

let unzip$1 = Belt_Array.unzip;

let concat$1 = Belt_Array.concat;

let concatMany$1 = Belt_Array.concatMany;

let slice$1 = Belt_Array.slice;

let sliceToEnd$1 = Belt_Array.sliceToEnd;

let fill$1 = Belt_Array.fill;

let blit$1 = Belt_Array.blit;

let blitUnsafe$1 = Belt_Array.blitUnsafe;

let forEachU = Belt_Array.forEachU;

let forEach$1 = Belt_Array.forEach;

let mapU = Belt_Array.mapU;

let map$1 = Belt_Array.map;

let flatMapU = Belt_Array.flatMapU;

let flatMap = Belt_Array.flatMap;

let getByU = Belt_Array.getByU;

let getBy$1 = Belt_Array.getBy;

let getIndexByU = Belt_Array.getIndexByU;

let getIndexBy$1 = Belt_Array.getIndexBy;

let keepU = Belt_Array.keepU;

let keep$1 = Belt_Array.keep;

let keepWithIndexU = Belt_Array.keepWithIndexU;

let keepWithIndex$1 = Belt_Array.keepWithIndex;

let keepMapU = Belt_Array.keepMapU;

let keepMap$1 = Belt_Array.keepMap;

let forEachWithIndexU = Belt_Array.forEachWithIndexU;

let forEachWithIndex$1 = Belt_Array.forEachWithIndex;

let mapWithIndexU = Belt_Array.mapWithIndexU;

let mapWithIndex$1 = Belt_Array.mapWithIndex;

let partitionU = Belt_Array.partitionU;

let partition$1 = Belt_Array.partition;

let reduceU = Belt_Array.reduceU;

let reduce$1 = Belt_Array.reduce;

let reduceReverseU = Belt_Array.reduceReverseU;

let reduceReverse$1 = Belt_Array.reduceReverse;

let reduceReverse2U = Belt_Array.reduceReverse2U;

let reduceReverse2$1 = Belt_Array.reduceReverse2;

let reduceWithIndexU = Belt_Array.reduceWithIndexU;

let reduceWithIndex$1 = Belt_Array.reduceWithIndex;

let joinWithU = Belt_Array.joinWithU;

let joinWith$2 = Belt_Array.joinWith;

let someU = Belt_Array.someU;

let some$1 = Belt_Array.some;

let everyU = Belt_Array.everyU;

let every$1 = Belt_Array.every;

let every2U = Belt_Array.every2U;

let every2$1 = Belt_Array.every2;

let some2U = Belt_Array.some2U;

let some2$1 = Belt_Array.some2;

let cmpU = Belt_Array.cmpU;

let cmp$1 = Belt_Array.cmp;

let eqU = Belt_Array.eqU;

let eq$1 = Belt_Array.eq;

let initU = Belt_Array.initU;

let init = Belt_Array.init;

let NonEmpty_String = {
  joinWith: joinWith,
  groupBy: groupBy$5,
  indexBy: indexBy$5
};

let NonEmpty = {
  length: length,
  size: size,
  get: get,
  getExn: getExn,
  getUnsafe: getUnsafe,
  getUndefined: getUndefined,
  set: set,
  setExn: setExn,
  setUnsafe: setUnsafe,
  shuffleInPlace: shuffleInPlace,
  shuffle: shuffle,
  reverseInPlace: reverseInPlace,
  reverse: reverse,
  zip: zip,
  zipBy: zipBy,
  unzip: unzip,
  concat: concat,
  concatMany: concatMany,
  slice: slice,
  sliceToEnd: sliceToEnd,
  copy: copy,
  fill: fill,
  blit: blit,
  blitUnsafe: blitUnsafe,
  forEach: forEach,
  map: map,
  getBy: getBy,
  getIndexBy: getIndexBy,
  keep: keep,
  keepWithIndex: keepWithIndex,
  keepMap: keepMap,
  forEachWithIndex: forEachWithIndex,
  mapWithIndex: mapWithIndex,
  partition: partition,
  reduce: reduce,
  reduceReverse: reduceReverse,
  reduceReverse2: reduceReverse2,
  reduceWithIndex: reduceWithIndex,
  joinWith: joinWith$1,
  some: some,
  every: every,
  some2: some2,
  every2: every2,
  cmp: cmp,
  eq: eq,
  truncateToLengthUnsafe: truncateToLengthUnsafe,
  fromArray: fromArray,
  fromArrayExn: fromArrayExn,
  toArray: toArray,
  first: first$1,
  last: last$1,
  reduce1: reduce1,
  minBy: minBy,
  maxBy: maxBy,
  take: take$1,
  takeWhile: takeWhile$1,
  drop: drop$1,
  dropWhile: dropWhile$1,
  updateUnsafe: updateUnsafe$1,
  updateExn: updateExn$1,
  keepSome: keepSome$1,
  groupBy: groupBy$3,
  indexBy: indexBy$3,
  frequencies: frequencies$1,
  distinct: distinct$1,
  distinctBy: distinctBy$1,
  scan: scan$1,
  chunk: chunk$1,
  randomOne: randomOne$1,
  randomSample: randomSample$1,
  intersperse: intersperse$1,
  Int: Int$1,
  $$String: NonEmpty_String
};

export {
  get$1 as get,
  getExn$1 as getExn,
  getOrThrow,
  set$1 as set,
  setExn$1 as setExn,
  setOrThrow,
  shuffleInPlace$1 as shuffleInPlace,
  shuffle$1 as shuffle,
  reverseInPlace$1 as reverseInPlace,
  reverse$1 as reverse,
  make,
  range,
  rangeBy,
  makeByU,
  makeBy,
  makeByAndShuffleU,
  makeByAndShuffle,
  zip$1 as zip,
  zipByU,
  zipBy$1 as zipBy,
  unzip$1 as unzip,
  concat$1 as concat,
  concatMany$1 as concatMany,
  slice$1 as slice,
  sliceToEnd$1 as sliceToEnd,
  fill$1 as fill,
  blit$1 as blit,
  blitUnsafe$1 as blitUnsafe,
  forEachU,
  forEach$1 as forEach,
  mapU,
  map$1 as map,
  flatMapU,
  flatMap,
  getByU,
  getBy$1 as getBy,
  getIndexByU,
  getIndexBy$1 as getIndexBy,
  keepU,
  keep$1 as keep,
  keepWithIndexU,
  keepWithIndex$1 as keepWithIndex,
  keepMapU,
  keepMap$1 as keepMap,
  forEachWithIndexU,
  forEachWithIndex$1 as forEachWithIndex,
  mapWithIndexU,
  mapWithIndex$1 as mapWithIndex,
  partitionU,
  partition$1 as partition,
  reduceU,
  reduce$1 as reduce,
  reduceReverseU,
  reduceReverse$1 as reduceReverse,
  reduceReverse2U,
  reduceReverse2$1 as reduceReverse2,
  reduceWithIndexU,
  reduceWithIndex$1 as reduceWithIndex,
  joinWithU,
  joinWith$2 as joinWith,
  someU,
  some$1 as some,
  everyU,
  every$1 as every,
  every2U,
  every2$1 as every2,
  some2U,
  some2$1 as some2,
  cmpU,
  cmp$1 as cmp,
  eqU,
  eq$1 as eq,
  initU,
  init,
  isEmpty,
  firstUnsafe,
  firstExn,
  first,
  lastUnsafe,
  lastExn,
  last,
  take,
  takeWhile,
  drop,
  dropWhile,
  updateUnsafe,
  updateExn,
  keepSome,
  groupBy,
  indexBy,
  frequencies,
  distinctBy,
  distinct,
  scan,
  chunk,
  randomOne,
  randomSample,
  intersperse,
  Int,
  $$String,
  NonEmpty,
}
/* No side effect */
