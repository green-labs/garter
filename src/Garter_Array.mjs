// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "@rescript/std/lib/es6/curry.js";
import * as Js_math from "@rescript/std/lib/es6/js_math.js";
import * as Belt_Map from "@rescript/std/lib/es6/belt_Map.js";
import * as Belt_Set from "@rescript/std/lib/es6/belt_Set.js";
import * as Belt_List from "@rescript/std/lib/es6/belt_List.js";
import * as Garter_Fn from "./Garter_Fn.mjs";
import * as Belt_Array from "@rescript/std/lib/es6/belt_Array.js";
import * as Belt_MapInt from "@rescript/std/lib/es6/belt_MapInt.js";
import * as Belt_MapString from "@rescript/std/lib/es6/belt_MapString.js";

function isEmpty(xs) {
  return xs.length === 0;
}

function firstUnsafe(__x) {
  return __x[0];
}

function firstExn(__x) {
  return Belt_Array.getExn(__x, 0);
}

function first(__x) {
  return Belt_Array.get(__x, 0);
}

function lastUnsafe(ar) {
  return ar[ar.length - 1 | 0];
}

function lastExn(ar) {
  return Belt_Array.getExn(ar, ar.length - 1 | 0);
}

function last(ar) {
  return Belt_Array.get(ar, ar.length - 1 | 0);
}

function take(ar, n) {
  var len = n < 0 ? 0 : (
      n > ar.length ? ar.length : n
    );
  return ar.slice(0, len);
}

function takeWhileU(ar, pred) {
  var i = 0;
  while(i < ar.length && pred(ar[i])) {
    i = i + 1 | 0;
  };
  return take(ar, i);
}

function takeWhile(ar, pred) {
  return takeWhileU(ar, Curry.__1(pred));
}

function drop(ar, n) {
  var offset = n < 0 ? 0 : (
      n > ar.length ? ar.length : n
    );
  return ar.slice(offset);
}

function dropWhileU(ar, pred) {
  var i = 0;
  while(i < ar.length && pred(ar[i])) {
    i = i + 1 | 0;
  };
  return drop(ar, i);
}

function dropWhile(ar, pred) {
  return dropWhileU(ar, Curry.__1(pred));
}

function updateUnsafeU(ar, i, f) {
  var v = ar[i];
  ar[i] = f(v);
}

function updateUnsafe(ar, i, f) {
  updateUnsafeU(ar, i, Curry.__1(f));
}

function updateExnU(ar, i, f) {
  var v = Belt_Array.getExn(ar, i);
  ar[i] = f(v);
}

function updateExn(ar, i, f) {
  updateExnU(ar, i, Curry.__1(f));
}

function keepSome(xs) {
  return Belt_Array.keepMap(xs, (function (x) {
                return x;
              }));
}

function groupBy(xs, keyFn, id) {
  var empty = Belt_Map.make(id);
  return Belt_Array.reduceU(xs, empty, (function (res, x) {
                return Belt_Map.updateU(res, Curry._1(keyFn, x), (function (v) {
                              if (v !== undefined) {
                                return Belt_Array.concat(v, [x]);
                              } else {
                                return [x];
                              }
                            }));
              }));
}

function indexBy(xs, indexFn, id) {
  var empty = Belt_Map.make(id);
  return Belt_Array.reduceU(xs, empty, (function (res, x) {
                return Belt_Map.set(res, Curry._1(indexFn, x), x);
              }));
}

function frequencies(ar, id) {
  return Belt_Map.map(groupBy(ar, Garter_Fn.identity, id), (function (prim) {
                return prim.length;
              }));
}

function distinct(ar, id) {
  return Belt_List.toArray(Belt_List.reverse(Belt_Array.reduceU(ar, [
                        Belt_Set.make(id),
                        /* [] */0
                      ], (function (param, v) {
                          var res = param[1];
                          var seen = param[0];
                          if (Belt_Set.has(seen, v)) {
                            return [
                                    seen,
                                    res
                                  ];
                          } else {
                            return [
                                    Belt_Set.add(seen, v),
                                    Belt_List.add(res, v)
                                  ];
                          }
                        }))[1]));
}

function scan(xs, init, f) {
  var state = new Array(xs.length);
  var cur = {
    contents: init
  };
  Belt_Array.forEachWithIndex(xs, (function (idx, x) {
          cur.contents = Curry._2(f, cur.contents, x);
          state[idx] = cur.contents;
        }));
  return state;
}

function chunk(xs, step) {
  return Belt_Array.map(Belt_Array.rangeBy(0, xs.length - 1 | 0, step), (function (offset) {
                return xs.slice(offset, offset + step | 0);
              }));
}

function randomOne(xs) {
  return Belt_Array.get(xs, Js_math.random_int(0, xs.length));
}

function randomSample(xs, prob) {
  return Belt_Array.keep(xs, (function (param) {
                return Math.random() < prob;
              }));
}

function intersperse(xs, delim) {
  var xlen = xs.length;
  if (xlen === 0) {
    return [];
  }
  if (xlen === 1) {
    return xs;
  }
  var ys = Belt_Array.make((xlen << 1) - 1 | 0, delim);
  Belt_Array.forEachWithIndex(xs, (function (i, x) {
          ys[(i << 1)] = x;
        }));
  return ys;
}

function groupBy$1(xs, keyFn) {
  return Belt_Array.reduceU(xs, undefined, (function (res, x) {
                return Belt_MapInt.updateU(res, Curry._1(keyFn, x), (function (v) {
                              if (v !== undefined) {
                                return Belt_Array.concat(v, [x]);
                              } else {
                                return [x];
                              }
                            }));
              }));
}

function indexBy$1(xs, indexFn) {
  return Belt_Array.reduceU(xs, undefined, (function (res, x) {
                return Belt_MapInt.set(res, Curry._1(indexFn, x), x);
              }));
}

var Int = {
  groupBy: groupBy$1,
  indexBy: indexBy$1
};

function joinWith(xs, s) {
  return Belt_Array.joinWithU(xs, s, (function (x) {
                return x;
              }));
}

function groupBy$2(xs, keyFn) {
  return Belt_Array.reduceU(xs, undefined, (function (res, x) {
                return Belt_MapString.updateU(res, Curry._1(keyFn, x), (function (v) {
                              if (v !== undefined) {
                                return Belt_Array.concat(v, [x]);
                              } else {
                                return [x];
                              }
                            }));
              }));
}

function indexBy$2(xs, indexFn) {
  return Belt_Array.reduceU(xs, undefined, (function (res, x) {
                return Belt_MapString.set(res, Curry._1(indexFn, x), x);
              }));
}

var $$String = {
  joinWith: joinWith,
  groupBy: groupBy$2,
  indexBy: indexBy$2
};

function fromArray(xs) {
  if (xs.length !== 0) {
    return xs;
  }
  
}

function fromArrayExn(xs) {
  if (xs.length !== 0) {
    return xs;
  }
  throw {
        RE_EXN_ID: "Invalid_argument",
        _1: "array is empty",
        Error: new Error()
      };
}

function toArray(nxs) {
  return nxs;
}

function first$1(nxs) {
  return nxs[0];
}

var last$1 = lastUnsafe;

function reduce1U(xs, f) {
  var r = xs[0];
  for(var i = 1 ,i_finish = xs.length; i < i_finish; ++i){
    r = f(r, xs[i]);
  }
  return r;
}

function reduce1(xs, f) {
  return reduce1U(xs, Curry.__2(f));
}

function minByU(xs, cmp) {
  return reduce1U(xs, (function (a, b) {
                if (cmp(a, b) > 0) {
                  return b;
                } else {
                  return a;
                }
              }));
}

function minBy(xs, cmp) {
  return minByU(xs, Curry.__2(cmp));
}

function maxByU(xs, cmp) {
  return reduce1U(xs, (function (a, b) {
                if (cmp(a, b) < 0) {
                  return b;
                } else {
                  return a;
                }
              }));
}

function maxBy(xs, cmp) {
  return maxByU(xs, Curry.__2(cmp));
}

var take$1 = take;

var takeWhileU$1 = takeWhileU;

function takeWhile$1(nxs, n) {
  return takeWhileU(nxs, Curry.__1(n));
}

var drop$1 = drop;

var dropWhileU$1 = dropWhileU;

function dropWhile$1(nxs, pred) {
  return dropWhileU(nxs, Curry.__1(pred));
}

var updateUnsafeU$1 = updateUnsafeU;

var updateUnsafe$1 = updateUnsafe;

var updateExnU$1 = updateExnU;

var updateExn$1 = updateExn;

function keepSome$1(nxs) {
  return Belt_Array.keepMap(nxs, (function (x) {
                return x;
              }));
}

var groupBy$3 = groupBy;

var indexBy$3 = indexBy;

var frequencies$1 = frequencies;

function distinct$1(nxs, id) {
  return fromArrayExn(distinct(nxs, id));
}

function scan$1(nxs, init, f) {
  return fromArrayExn(scan(nxs, init, f));
}

function chunk$1(nxs, step) {
  return fromArrayExn(chunk(nxs, step));
}

function randomOne$1(nxs) {
  return nxs[Js_math.random_int(0, nxs.length)];
}

var randomSample$1 = randomSample;

function intersperse$1(nxs, delim) {
  return fromArrayExn(intersperse(nxs, delim));
}

var groupBy$4 = groupBy$1;

var indexBy$4 = indexBy$1;

var Int$1 = {
  groupBy: groupBy$4,
  indexBy: indexBy$4
};

var groupBy$5 = groupBy$2;

var indexBy$5 = indexBy$2;

var get = Belt_Array.get;

var getExn = Belt_Array.getExn;

var set = Belt_Array.set;

var setExn = Belt_Array.setExn;

var shuffleInPlace = Belt_Array.shuffleInPlace;

var shuffle = Belt_Array.shuffle;

var reverseInPlace = Belt_Array.reverseInPlace;

var reverse = Belt_Array.reverse;

var make = Belt_Array.make;

var range = Belt_Array.range;

var rangeBy = Belt_Array.rangeBy;

var makeByU = Belt_Array.makeByU;

var makeBy = Belt_Array.makeBy;

var makeByAndShuffleU = Belt_Array.makeByAndShuffleU;

var makeByAndShuffle = Belt_Array.makeByAndShuffle;

var zip = Belt_Array.zip;

var zipByU = Belt_Array.zipByU;

var zipBy = Belt_Array.zipBy;

var unzip = Belt_Array.unzip;

var concat = Belt_Array.concat;

var concatMany = Belt_Array.concatMany;

var slice = Belt_Array.slice;

var sliceToEnd = Belt_Array.sliceToEnd;

var fill = Belt_Array.fill;

var blit = Belt_Array.blit;

var blitUnsafe = Belt_Array.blitUnsafe;

var forEachU = Belt_Array.forEachU;

var forEach = Belt_Array.forEach;

var mapU = Belt_Array.mapU;

var map = Belt_Array.map;

var flatMapU = Belt_Array.flatMapU;

var flatMap = Belt_Array.flatMap;

var getByU = Belt_Array.getByU;

var getBy = Belt_Array.getBy;

var getIndexByU = Belt_Array.getIndexByU;

var getIndexBy = Belt_Array.getIndexBy;

var keepU = Belt_Array.keepU;

var keep = Belt_Array.keep;

var keepWithIndexU = Belt_Array.keepWithIndexU;

var keepWithIndex = Belt_Array.keepWithIndex;

var keepMapU = Belt_Array.keepMapU;

var keepMap = Belt_Array.keepMap;

var forEachWithIndexU = Belt_Array.forEachWithIndexU;

var forEachWithIndex = Belt_Array.forEachWithIndex;

var mapWithIndexU = Belt_Array.mapWithIndexU;

var mapWithIndex = Belt_Array.mapWithIndex;

var partitionU = Belt_Array.partitionU;

var partition = Belt_Array.partition;

var reduceU = Belt_Array.reduceU;

var reduce = Belt_Array.reduce;

var reduceReverseU = Belt_Array.reduceReverseU;

var reduceReverse = Belt_Array.reduceReverse;

var reduceReverse2U = Belt_Array.reduceReverse2U;

var reduceReverse2 = Belt_Array.reduceReverse2;

var reduceWithIndexU = Belt_Array.reduceWithIndexU;

var reduceWithIndex = Belt_Array.reduceWithIndex;

var joinWithU = Belt_Array.joinWithU;

var joinWith$1 = Belt_Array.joinWith;

var someU = Belt_Array.someU;

var some = Belt_Array.some;

var everyU = Belt_Array.everyU;

var every = Belt_Array.every;

var every2U = Belt_Array.every2U;

var every2 = Belt_Array.every2;

var some2U = Belt_Array.some2U;

var some2 = Belt_Array.some2;

var cmpU = Belt_Array.cmpU;

var cmp = Belt_Array.cmp;

var eqU = Belt_Array.eqU;

var eq = Belt_Array.eq;

var initU = Belt_Array.initU;

var init = Belt_Array.init;

function NonEmpty_length(prim) {
  return prim.length;
}

function NonEmpty_size(prim) {
  return prim.length;
}

function NonEmpty_getUnsafe(prim0, prim1) {
  return prim0[prim1];
}

function NonEmpty_getUndefined(prim0, prim1) {
  return prim0[prim1];
}

function NonEmpty_setUnsafe(prim0, prim1, prim2) {
  prim0[prim1] = prim2;
}

function NonEmpty_copy(prim) {
  return prim.slice(0);
}

function NonEmpty_truncateToLengthUnsafe(prim0, prim1) {
  prim0.length = prim1;
}

var NonEmpty_String = {
  joinWith: joinWith,
  groupBy: groupBy$5,
  indexBy: indexBy$5
};

var NonEmpty = {
  length: NonEmpty_length,
  size: NonEmpty_size,
  get: Belt_Array.get,
  getExn: Belt_Array.getExn,
  getUnsafe: NonEmpty_getUnsafe,
  getUndefined: NonEmpty_getUndefined,
  set: Belt_Array.set,
  setExn: Belt_Array.setExn,
  setUnsafe: NonEmpty_setUnsafe,
  shuffleInPlace: Belt_Array.shuffleInPlace,
  shuffle: Belt_Array.shuffle,
  reverseInPlace: Belt_Array.reverseInPlace,
  reverse: Belt_Array.reverse,
  zip: Belt_Array.zip,
  zipByU: Belt_Array.zipByU,
  zipBy: Belt_Array.zipBy,
  unzip: Belt_Array.unzip,
  concat: Belt_Array.concat,
  concatMany: Belt_Array.concatMany,
  slice: Belt_Array.slice,
  sliceToEnd: Belt_Array.sliceToEnd,
  copy: NonEmpty_copy,
  fill: Belt_Array.fill,
  blit: Belt_Array.blit,
  blitUnsafe: Belt_Array.blitUnsafe,
  forEachU: Belt_Array.forEachU,
  forEach: Belt_Array.forEach,
  mapU: Belt_Array.mapU,
  map: Belt_Array.map,
  getByU: Belt_Array.getByU,
  getBy: Belt_Array.getBy,
  getIndexByU: Belt_Array.getIndexByU,
  getIndexBy: Belt_Array.getIndexBy,
  keepU: Belt_Array.keepU,
  keep: Belt_Array.keep,
  keepWithIndexU: Belt_Array.keepWithIndexU,
  keepWithIndex: Belt_Array.keepWithIndex,
  keepMapU: Belt_Array.keepMapU,
  keepMap: Belt_Array.keepMap,
  forEachWithIndexU: Belt_Array.forEachWithIndexU,
  forEachWithIndex: Belt_Array.forEachWithIndex,
  mapWithIndexU: Belt_Array.mapWithIndexU,
  mapWithIndex: Belt_Array.mapWithIndex,
  partitionU: Belt_Array.partitionU,
  partition: Belt_Array.partition,
  reduceU: Belt_Array.reduceU,
  reduce: Belt_Array.reduce,
  reduceReverseU: Belt_Array.reduceReverseU,
  reduceReverse: Belt_Array.reduceReverse,
  reduceReverse2U: Belt_Array.reduceReverse2U,
  reduceReverse2: Belt_Array.reduceReverse2,
  reduceWithIndexU: Belt_Array.reduceWithIndexU,
  reduceWithIndex: Belt_Array.reduceWithIndex,
  joinWithU: Belt_Array.joinWithU,
  joinWith: Belt_Array.joinWith,
  someU: Belt_Array.someU,
  some: Belt_Array.some,
  everyU: Belt_Array.everyU,
  every: Belt_Array.every,
  some2U: Belt_Array.some2U,
  some2: Belt_Array.some2,
  every2U: Belt_Array.every2U,
  every2: Belt_Array.every2,
  cmpU: Belt_Array.cmpU,
  cmp: Belt_Array.cmp,
  eqU: Belt_Array.eqU,
  eq: Belt_Array.eq,
  truncateToLengthUnsafe: NonEmpty_truncateToLengthUnsafe,
  fromArray: fromArray,
  fromArrayExn: fromArrayExn,
  toArray: toArray,
  first: first$1,
  last: last$1,
  reduce1U: reduce1U,
  reduce1: reduce1,
  minByU: minByU,
  minBy: minBy,
  maxByU: maxByU,
  maxBy: maxBy,
  take: take$1,
  takeWhileU: takeWhileU$1,
  takeWhile: takeWhile$1,
  drop: drop$1,
  dropWhileU: dropWhileU$1,
  dropWhile: dropWhile$1,
  updateUnsafeU: updateUnsafeU$1,
  updateUnsafe: updateUnsafe$1,
  updateExnU: updateExnU$1,
  updateExn: updateExn$1,
  keepSome: keepSome$1,
  groupBy: groupBy$3,
  indexBy: indexBy$3,
  frequencies: frequencies$1,
  distinct: distinct$1,
  scan: scan$1,
  chunk: chunk$1,
  randomOne: randomOne$1,
  randomSample: randomSample$1,
  intersperse: intersperse$1,
  Int: Int$1,
  $$String: NonEmpty_String
};

export {
  get ,
  getExn ,
  set ,
  setExn ,
  shuffleInPlace ,
  shuffle ,
  reverseInPlace ,
  reverse ,
  make ,
  range ,
  rangeBy ,
  makeByU ,
  makeBy ,
  makeByAndShuffleU ,
  makeByAndShuffle ,
  zip ,
  zipByU ,
  zipBy ,
  unzip ,
  concat ,
  concatMany ,
  slice ,
  sliceToEnd ,
  fill ,
  blit ,
  blitUnsafe ,
  forEachU ,
  forEach ,
  mapU ,
  map ,
  flatMapU ,
  flatMap ,
  getByU ,
  getBy ,
  getIndexByU ,
  getIndexBy ,
  keepU ,
  keep ,
  keepWithIndexU ,
  keepWithIndex ,
  keepMapU ,
  keepMap ,
  forEachWithIndexU ,
  forEachWithIndex ,
  mapWithIndexU ,
  mapWithIndex ,
  partitionU ,
  partition ,
  reduceU ,
  reduce ,
  reduceReverseU ,
  reduceReverse ,
  reduceReverse2U ,
  reduceReverse2 ,
  reduceWithIndexU ,
  reduceWithIndex ,
  joinWithU ,
  joinWith$1 as joinWith,
  someU ,
  some ,
  everyU ,
  every ,
  every2U ,
  every2 ,
  some2U ,
  some2 ,
  cmpU ,
  cmp ,
  eqU ,
  eq ,
  initU ,
  init ,
  isEmpty ,
  firstUnsafe ,
  firstExn ,
  first ,
  lastUnsafe ,
  lastExn ,
  last ,
  take ,
  takeWhileU ,
  takeWhile ,
  drop ,
  dropWhileU ,
  dropWhile ,
  updateUnsafeU ,
  updateUnsafe ,
  updateExnU ,
  updateExn ,
  keepSome ,
  groupBy ,
  indexBy ,
  frequencies ,
  distinct ,
  scan ,
  chunk ,
  randomOne ,
  randomSample ,
  intersperse ,
  Int ,
  $$String ,
  NonEmpty ,
}
/* No side effect */
